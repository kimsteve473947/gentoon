'use client';

import { useEffect, useState, useCallback } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { createBrowserClient } from '@supabase/ssr';
import { MiriCanvasStudioUltimate } from "@/components/studio/MiriCanvasStudioUltimate";

// UUID ÏÉùÏÑ± Ìï®Ïàò
const generateUUID = () => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};

export default function StudioContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const projectId = searchParams.get('projectId');
  const [projectData, setProjectData] = useState<any>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  
  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  // üöÄ Ï¶âÏãú Ï¥àÍ∏∞Ìôî - Ïã§Ï†ú DB ÏÇ¨Ïö©
  useEffect(() => {
    const initializeStudio = async () => {
      try {
        console.log('üöÄ Studio initialization with real DB');
        
        // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© (Í∞úÎ∞ú/ÌîÑÎ°úÎçïÏÖò ÎèôÏùº)
        if (projectId) {
          await loadProject();
        } else {
          await createNewProject();
        }
      } catch (error) {
        console.error('Studio initialization error:', error);
        // ÏóêÎü¨ Î∞úÏÉùÏãúÏóêÎèÑ Í∏∞Î≥∏ ÌîÑÎ°úÏ†ùÌä∏Î°ú Ï¥àÍ∏∞Ìôî
        setProjectData({
          id: 'temp',
          title: 'Î¨¥Ï†ú ÌîÑÎ°úÏ†ùÌä∏',
          userId: 'temp',
          workspacesettings: {}
        });
      } finally {
        setIsInitialized(true);
      }
    };

    initializeStudio();
  }, [projectId]);

  const loadProject = useCallback(async () => {
    try {
      // üöÄ Í∞úÎ∞ú/ÌîÑÎ°úÎçïÏÖò Î™®Îìú ÌÜµÌï© - Ïã§Ï†ú DBÏóêÏÑú ÌîÑÎ°úÏ†ùÌä∏ Ï°∞Ìöå

      // ÌîÑÎ°úÎçïÏÖò Î™®ÎìúÏóêÏÑúÎäî Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï°∞Ìöå
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/sign-in?redirectTo=/studio');
        return;
      }

      const { data, error } = await supabase
        .from('project')
        .select('*')
        .eq('id', projectId)
        .eq('userId', user.id)
        .single();

      if (error) throw error;
      setProjectData(data);
    } catch (error) {
      console.error('Error loading project:', error);
      // ÌîÑÎ°úÏ†ùÌä∏ Î°úÎìú Ïã§Ìå® Ïãú ÏÉà ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±
      await createNewProject();
    }
  }, [projectId, router, supabase]);

  const createNewProject = useCallback(async () => {
    try {
      // üöÄ Í∞úÎ∞ú/ÌîÑÎ°úÎçïÏÖò Î™®Îìú ÌÜµÌï© - Ïã§Ï†ú DBÏóê ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±

      // ÌîÑÎ°úÎçïÏÖò Î™®ÎìúÏóêÏÑúÎäî Ïã§Ï†ú ÌîÑÎ°úÏ†ùÌä∏ ÏÉùÏÑ±
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/sign-in?redirectTo=/studio');
        return;
      }

      const { data: userData } = await supabase
        .from('user')
        .select('id')
        .eq('id', user.id)
        .single();

      if (!userData) {
        const { data: newUser, error: createError } = await supabase
          .from('user')
          .insert({ 
            id: user.id,
            email: user.email,
            name: user.user_metadata?.full_name || user.email?.split('@')[0] || 'User'
          })
          .select()
          .single();
        
        if (createError || !newUser) {
          console.error('Error creating user:', createError);
          return;
        }
        
        const newProject = {
          userId: newUser.id,
          title: 'Î¨¥Ï†ú ÌîÑÎ°úÏ†ùÌä∏',
          description: '',
          status: 'DRAFT',
          isPublic: false,
          isdraft: true,
          workspacesettings: {},
          tags: [],
          episodecount: 0,
          viewcount: 0,
          likecount: 0
        };

        const { data, error } = await supabase
          .from('project')
          .insert(newProject)
          .select()
          .single();

        if (error) throw error;
        
        router.replace(`/studio?projectId=${data.id}`);
        setProjectData(data);
        return;
      }

      const newProject = {
        userId: userData.id,
        title: 'Î¨¥Ï†ú ÌîÑÎ°úÏ†ùÌä∏',
        description: '',
        status: 'DRAFT',
        isPublic: false,
        isdraft: true,
        workspacesettings: {},
        tags: [],
        episodecount: 0,
        viewcount: 0,
        likecount: 0
      };

      const { data, error } = await supabase
        .from('project')
        .insert(newProject)
        .select()
        .single();

      if (error) throw error;
      
      router.replace(`/studio?projectId=${data.id}`);
      setProjectData(data);
    } catch (error) {
      console.error('Error creating project:', error);
    }
  }, [router, supabase]);

  // üöÄ üöÄ üöÄ ÏôÑÏ†ÑÌûà ÏµúÏ†ÅÌôîÎêú ÌîÑÎ°úÏ†ùÌä∏ Ï†ÄÏû• Î°úÏßÅ üöÄ üöÄ üöÄ
  const saveProject = async (panels: any[], title?: string) => {
    if (!projectData) {
      console.error('‚ùå No project data available for saving');
      return;
    }

    const startTime = Date.now();

    // üöÄ Í∞úÎ∞ú Î™®ÎìúÏóêÏÑúÎèÑ Ïã§Ï†ú DB ÏÇ¨Ïö© (API Ìò∏Ï∂úÍ≥º ÏùºÍ¥ÄÏÑ± Ïú†ÏßÄ)
    console.log('üíæ Using database save for consistency with API calls');

    // ÌîÑÎ°úÎçïÏÖò Î™®ÎìúÏóêÏÑúÎäî Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû•
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      console.error('‚ùå User not authenticated');
      router.push('/sign-in?redirectTo=/studio');
      return;
    }

    if (projectData.userId !== user.id) {
      console.error('‚ùå User does not own this project');
      throw new Error('ÌîÑÎ°úÏ†ùÌä∏Ïóê ÎåÄÌïú Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.');
    }

    console.log('üöÄ [OPTIMIZED] Starting super-fast project save:', {
      projectId: projectData.id,
      panelCount: panels?.length || 0,
      title: title || 'no title change'
    });

    try {
      // 1. ÌîÑÎ°úÏ†ùÌä∏ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (Î≥ëÎ†¨ Ï≤òÎ¶¨ Ï§ÄÎπÑ)
      const { panels: _, ...cleanWorkspaceSettings } = projectData.workspacesettings || {};
      const updateData: any = {
        lasteditedat: new Date().toISOString(),
        workspacesettings: cleanWorkspaceSettings
      };

      if (title) {
        updateData.title = title;
      }

      // 2. üöÄ ÌïµÏã¨ ÏµúÏ†ÅÌôî: ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏ÏôÄ Ìå®ÎÑê UPSERTÎ•º Î≥ëÎ†¨ Ï≤òÎ¶¨
      const promises = [];

      // ÌîÑÎ°úÏ†ùÌä∏ ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
      promises.push(
        supabase
          .from('project')
          .update(updateData)
          .eq('id', projectData.id)
          .then(result => {
            if (result.error) throw result.error;
            console.log('‚úÖ Project metadata updated');
            return result;
          })
      );

      // Ìå®ÎÑê Îç∞Ïù¥ÌÑ∞ ÏµúÏ†ÅÌôî Ï†ÄÏû•
      if (panels && panels.length > 0) {
        console.log(`üöÄ [ULTRA-FAST] Direct UPSERT for ${panels.length} panels - NO DELETE!`);
        
        // üéØ ÌïµÏã¨ Í∞úÏÑ†: ÏÇ≠Ï†ú ÏóÜÏù¥ Î∞îÎ°ú UPSERT
        const panelData = panels.map((panel, index) => ({
          projectId: projectData.id,
          order: index,
          prompt: panel.prompt || '',
          imageUrl: panel.imageUrl || null,
          editData: panel.editData || null
        }));

        // üöÄ ÎåÄÎüâ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨: Ïä§ÎßàÌä∏ Î∞∞Ïπò ÌÅ¨Í∏∞ Í≤∞Ï†ï
        const batchSize = panels.length > 200 ? 100 : 
                         panels.length > 50 ? 50 : panels.length;
        
        for (let i = 0; i < panelData.length; i += batchSize) {
          const batch = panelData.slice(i, i + batchSize);
          const batchNum = Math.floor(i/batchSize) + 1;
          const totalBatches = Math.ceil(panelData.length/batchSize);
          
          console.log(`üî• [BATCH-${batchNum}/${totalBatches}] UPSERT ${batch.length} panels...`);
          
          // Î∞∞Ïπò UPSERTÎ•º promisesÏóê Ï∂îÍ∞Ä (Î≥ëÎ†¨ Ï≤òÎ¶¨)
          promises.push(
            supabase
              .from('panel')
              .upsert(batch, {
                onConflict: 'projectId,order',
                ignoreDuplicates: false
              })
              .then(result => {
                if (result.error) {
                  console.error(`‚ùå Batch ${batchNum} failed:`, result.error);
                  throw result.error;
                }
                console.log(`‚úÖ Batch ${batchNum} completed successfully`);
                return result;
              })
          );
        }

        // üßπ ÌïÑÏöîÏãúÏóêÎßå Ï†ïÎ¶¨: Í∏∞Ï°¥ Ìå®ÎÑêÎ≥¥Îã§ Ï†ÅÏñ¥ÏßÑ Í≤ΩÏö∞ÏóêÎßå ÏÇ≠Ï†ú
        if (panels.length > 0) {
          const maxOrder = panels.length - 1;
          promises.push(
            supabase
              .from('panel')
              .delete()
              .eq('projectId', projectData.id)
              .gt('"order"', maxOrder)
              .then(result => {
                if (result.error) {
                  console.warn('‚ö†Ô∏è Cleanup failed, but continuing...', result.error);
                } else {
                  console.log(`üßπ Cleaned up panels beyond order ${maxOrder}`);
                }
                return result;
              })
          );
        }
      }

      // üöÄ Î™®Îì† ÏûëÏóÖÏùÑ Î≥ëÎ†¨Î°ú Ïã§Ìñâ
      await Promise.all(promises);
      
      const totalTime = Date.now() - startTime;
      console.log(`üéâ [OPTIMIZED] Project saved successfully in ${totalTime}ms (${Math.round(totalTime/1000 * 10)/10}s)`);
      
      // ÏÑ±Îä• Î©îÌä∏Î¶≠ Î°úÍπÖ
      if (panels?.length > 0) {
        const panelsPerSecond = Math.round((panels.length / totalTime) * 1000);
        console.log(`üìä Performance: ${panelsPerSecond} panels/second`);
      }

    } catch (error: any) {
      const totalTime = Date.now() - startTime;
      console.error(`‚ùå [OPTIMIZED] Save failed after ${totalTime}ms:`, error);
      console.error('Error details:', JSON.stringify(error, null, 2));
      
      if (error && typeof error === 'object') {
        console.error('Error code:', error.code);
        console.error('Error status:', error.status);
        console.error('Error details from Supabase:', error.details);
        console.error('Error hint:', error.hint);
      }
      
      throw error;
    }
  };

  // üöÄ Ï¥àÍ∏∞ÌôîÍ∞Ä ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ ÏïÑÎ¨¥Í≤ÉÎèÑ Î†åÎçîÎßÅÌïòÏßÄ ÏïäÏùå (Suspense Ïä§ÏºàÎ†àÌÜ§Ïù¥ ÌëúÏãúÎê®)
  if (!isInitialized || !projectData) {
    return null;
  }

  // üöÄ Ï¶âÏãú Ïä§ÌäúÎîîÏò§ Ïª¥Ìè¨ÎÑåÌä∏ Î†åÎçîÎßÅ - Ï∂îÍ∞Ä Î°úÎî© ÏóÜÏùå
  return (
    <MiriCanvasStudioUltimate 
      projectId={projectData?.id}
      initialData={projectData}
      onSave={saveProject}
    />
  );
}