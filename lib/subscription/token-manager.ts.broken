import { prisma } from "@/lib/db/prisma";
import { SubscriptionPlan, TransactionType, TransactionStatus } from "@prisma/client";
import { createClient as createSupabaseClient } from "@/lib/supabase/server";
import { checkAndResetTokensIfNeeded, getUserTokenInfo } from "./token-reset";
import { SecureLogger, devLog, secureError } from "@/lib/utils/secure-logger";
import { PLAN_CONFIGS, getPlanConfig, type PlanType } from "./plan-config";

// Gemini 2.5 Flash ì´ë¯¸ì§€ ìƒì„± í† í° ì†Œë¹„ëŸ‰ ê¸°ì¤€
// ì‹¤ì œ Gemini API: ì´ë¯¸ì§€ë‹¹ ì•½ 1,290 í† í° (100ë§Œ í† í°ë‹¹ $30)
// ì´ë¯¸ì§€ë‹¹ ì›ê°€: ì•½ 52ì› (1,290 í† í° Ã— $0.00003 Ã— 1,330ì›/ë‹¬ëŸ¬)
const GEMINI_COST = {
  TOKENS_PER_IMAGE: 1290,           // Gemini ì‹¤ì œ í† í° ì†Œë¹„ëŸ‰
  COST_PER_MILLION: 30,              // $30 per 1M tokens
  USD_TO_KRW: 1450,                   // í™˜ìœ¨
  COST_PER_IMAGE_KRW: 52,            // ì´ë¯¸ì§€ë‹¹ ì›ê°€ (ì›)
} as const;

// í”Œë«í¼ í† í° ì„¤ì • (ìˆ˜ìµ ë§ˆì§„ ê³ ë ¤)
const PLATFORM_PRICING = {
  TOKENS_PER_IMAGE: 1,                 // í”Œë«í¼ í† í°: 1ì´ë¯¸ì§€ = 1í† í°
  HIGH_RESOLUTION_TOKENS: 0.5,        // ê³ í•´ìƒë„ ì¶”ê°€ í† í°
  CHARACTER_SAVE_TOKENS: 0.2,          // ìºë¦­í„° ì €ì¥ í† í°
  MARGIN_MULTIPLIER: 2.5,              // 2.5ë°° ë§ˆì§„ (ì›ê°€ 52ì› â†’ íŒë§¤ 130ì›)
} as const;

// í…ìŠ¤íŠ¸ ìƒì„± í† í° ì„¤ì • (Gemini 2.5 Flash í…ìŠ¤íŠ¸ ìƒì„±)
const TEXT_GENERATION_CONFIG = {
  COST_PER_MILLION: 1.5,               // $1.5 per 1M tokens (í…ìŠ¤íŠ¸ ìƒì„± ê°€ê²©)
  USD_TO_KRW: 1450,                    // í™˜ìœ¨
  PLAN_LIMITS: {
    FREE: 30000,                       // 3ë§Œ í† í°/ì›” (15íšŒ ëŒ€ë³¸ ìƒì„±)
    STARTER: 200000,                   // 20ë§Œ í† í°/ì›” (100íšŒ ëŒ€ë³¸ ìƒì„±)
    PRO: 600000,                       // 60ë§Œ í† í°/ì›” (300íšŒ ëŒ€ë³¸ ìƒì„±)
    PREMIUM: 2000000,                  // 200ë§Œ í† í°/ì›” (1000íšŒ ëŒ€ë³¸ ìƒì„±)
    ADMIN: 999999999,                  // ë¬´ì œí•œ
  }
} as const;

// êµ¬ë… í”Œëœ ì„¤ì •ì€ plan-config.tsì—ì„œ ì¤‘ì•™ ê´€ë¦¬

// í† í° ê´€ë¦¬ ì„œë¹„ìŠ¤
export class TokenManager {

  /**
   * Supabase í´ë¼ì´ì–¸íŠ¸ ìƒì„± (ì„œë²„ ì „ìš©)
   * ğŸ”’ ë³´ì•ˆ: ì„œë²„ì—ì„œë§Œ ì‹¤í–‰ë˜ë©° ì„œë¹„ìŠ¤ ì—­í•  í‚¤ ì‚¬ìš©
   */
  private async getSupabaseClient() {
    // ì„œë²„ í™˜ê²½ ì²´í¬
    if (typeof window !== 'undefined') {
      throw new Error('TokenManagerëŠ” ì„œë²„ì—ì„œë§Œ ì‹¤í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” APIë¥¼ í†µí•´ ì ‘ê·¼í•˜ì„¸ìš”.');
    }

    // ì„œë²„ ì „ìš© Supabase í´ë¼ì´ì–¸íŠ¸ ì‚¬ìš©
    return await createSupabaseClient();
  }

  // Google Gemini API ì‹¤ì œ í† í° ì‚¬ìš©ëŸ‰ ê¸°ë°˜ ì°¨ê° (ìƒˆë¡œìš´ ë©”ì„œë“œ)
  async useActualTokensFromGemini(
    userId: string, 
    actualGeminiTokens: number,
    options?: {
      imageCount?: number;
      highResolution?: boolean;
      saveCharacter?: boolean;
      description?: string;
    }
  ): Promise<{
    success: boolean;
    remainingTokens?: number;
    dailyRemaining?: number;
    error?: string;
  }> {
    try {
      SecureLogger.metrics(`ì‹¤ì œ Gemini í† í° ì‚¬ìš©ëŸ‰ ê¸°ë°˜ ì°¨ê°`, { geminiTokens: actualGeminiTokens });
      
      const supabase = await this.getSupabaseClient();
      
      // ì§ì ‘ Auth ID ì‚¬ìš© (ìë™ ìƒì„± í•„ìš”ì‹œ)
      let userData = await supabase
        .from('user')
        .select('id')
        .eq('id', userId)
        .single();

      if (!userData.data) {
        console.log(`ğŸ‘¤ ìƒˆë¡œìš´ ì‚¬ìš©ì ìë™ ìƒì„±: ${userId.substring(0, 8)}...`);
        
        // Supabase Authì—ì„œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        const { data: { user: authUser } } = await supabase.auth.admin.getUserById(userId);
        
        if (!authUser) {
          console.error(`Auth ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${userId}`);
          return {
            success: false,
            error: "Auth ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤",
          };
        }

        // ìƒˆ ì‚¬ìš©ì ìƒì„± (Auth IDë¥¼ ì§ì ‘ PKë¡œ ì‚¬ìš©)
        const { data: newUser } = await supabase
          .from('user')
          .insert({
            id: userId, // Auth IDë¥¼ ì§ì ‘ PKë¡œ ì‚¬ìš©
            email: authUser.email || '',
            name: authUser.user_metadata?.full_name || authUser.user_metadata?.name || authUser.email?.split('@')[0] || 'ì‚¬ìš©ì',
            avatarUrl: authUser.user_metadata?.avatar_url
          })
          .select('id')
          .single();

        if (!newUser) {
          console.error(`ìƒˆ ì‚¬ìš©ì ìƒì„± ì‹¤íŒ¨: ${userId}`);
          return {
            success: false,
            error: "ìƒˆ ì‚¬ìš©ì ìƒì„± ì‹¤íŒ¨",
          };
        }
        console.log(`âœ… ìƒˆë¡œìš´ ì‚¬ìš©ì ìƒì„± ì™„ë£Œ: ${userId.substring(0, 8)}...`);
      } else {
        console.log(`ğŸ”„ ê¸°ì¡´ ì‚¬ìš©ì í™•ì¸: ${userId.substring(0, 8)}...`);
      }

      // ì‹¤ì œ êµ¬ë… ì •ë³´ ì¡°íšŒ (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
      let subscription = await supabase
        .from('subscription')
        .select('*')
        .eq('userId', userId)
        .single();

      if (!subscription.data) {
        console.log(`ğŸ“‹ ìƒˆë¡œìš´ êµ¬ë… ìë™ ìƒì„±: ${userId.substring(0, 8)}...`);
        
        // FREE í”Œëœìœ¼ë¡œ ìƒˆ êµ¬ë… ìƒì„± (ë¶„ë¦¬ëœ í† í° í•„ë“œ ì‚¬ìš©)
        const { data: newSubscription } = await supabase
          .from('subscription')
          .insert({
            userId: userId,
            plan: 'FREE',
            // ğŸ”„ ìƒˆë¡œìš´ ë¶„ë¦¬ëœ í† í° í•„ë“œ
            imageTokensTotal: PLAN_CONFIGS.FREE.imageTokens,
            imageTokensUsed: 0,
            textTokensTotal: PLAN_CONFIGS.FREE.textTokens,
            textTokensUsed: 0,
            // ğŸš¨ ë ˆê±°ì‹œ í•„ë“œ (í•˜ìœ„ í˜¸í™˜ì„±)
            tokensTotal: PLAN_CONFIGS.FREE.platformTokens,
            tokensUsed: 0,
            maxCharacters: PLAN_CONFIGS.FREE.maxCharacters,
            currentPeriodStart: new Date(),
            currentPeriodEnd: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1ë…„ í›„
          })
          .select('*')
          .single();

        if (!newSubscription) {
          console.error(`ìƒˆ êµ¬ë… ìƒì„± ì‹¤íŒ¨: ${userId}`);
          return {
            success: false,
            error: "ìƒˆ êµ¬ë… ìƒì„± ì‹¤íŒ¨",
          };
        }

        subscription.data = newSubscription;
        console.log(`âœ… ìƒˆë¡œìš´ êµ¬ë… ìƒì„± ì™„ë£Œ: FREE í”Œëœ, ${PLAN_CONFIGS.FREE.platformTokens} í† í°`);
      }

      // ğŸ”„ ì´ë¯¸ì§€ í† í° ì”ì•¡ í™•ì¸ (ìƒˆë¡œìš´ ë¶„ë¦¬ëœ í•„ë“œ ì‚¬ìš©)
      const subscriptionData = subscription.data;
      const imageTokensTotal = subscriptionData.imageTokensTotal || subscriptionData.tokensTotal || 0;
      const imageTokensUsed = subscriptionData.imageTokensUsed || subscriptionData.tokensUsed || 0;
      const remainingImageTokens = imageTokensTotal - imageTokensUsed;
      
      console.log(`ğŸ¨ ì´ë¯¸ì§€ í† í° ì”ì•¡: ${imageTokensUsed.toLocaleString()}/${imageTokensTotal.toLocaleString()}í† í° ì‚¬ìš©`);
      
      if (remainingImageTokens < actualGeminiTokens) {
        console.warn(`ì´ë¯¸ì§€ í† í° ë¶€ì¡±: í•„ìš” ${actualGeminiTokens.toLocaleString()}, ì”ì•¡ ${remainingImageTokens.toLocaleString()}`);
        return {
          success: false,
          error: `ì´ë¯¸ì§€ ìƒì„± í† í°ì´ ë¶€ì¡±í•©ë‹ˆë‹¤ (í•„ìš”: ${actualGeminiTokens.toLocaleString()}, ì”ì•¡: ${remainingImageTokens.toLocaleString()})`,
          remainingTokens: remainingImageTokens,
        };
      }

      // ğŸ”„ subscription í…Œì´ë¸”ì˜ imageTokensUsed ì—…ë°ì´íŠ¸ (Prisma ìš°íšŒ íŒ¨ì¹˜)
      try {
        await prisma.subscription.update({
          where: { userId },
          data: {
            imageTokensUsed: {
              increment: actualGeminiTokens
            },
            // ë ˆê±°ì‹œ í•„ë“œë„ ë™ì‹œ ì—…ë°ì´íŠ¸ (í•˜ìœ„ í˜¸í™˜ì„±)
            tokensUsed: {
              increment: actualGeminiTokens
            }
          }
        });
      } catch (prismaError) {
        console.warn('âš ï¸ Prisma ì´ë¯¸ì§€ í† í° ì—…ë°ì´íŠ¸ ì‹¤íŒ¨, Supabase ì§ì ‘ ì—…ë°ì´íŠ¸ë¡œ ëŒ€ì²´:', prismaError);
        
        // Supabase ì§ì ‘ ì—…ë°ì´íŠ¸ë¡œ ëŒ€ì²´
        const supabase = await this.getSupabaseClient();
        const { error: updateError } = await supabase
          .from('subscription')
          .update({ 
            imageTokensUsed: currentUsedImageTokens + actualGeminiTokens,
            tokensUsed: currentUsedTokens + actualGeminiTokens // ë ˆê±°ì‹œ í˜¸í™˜ì„±
          })
          .eq('userId', userId);

        if (updateError) {
          console.error('âŒ Supabase ì´ë¯¸ì§€ í† í° ì—…ë°ì´íŠ¸ë„ ì‹¤íŒ¨:', updateError);
          throw new Error('ì´ë¯¸ì§€ í† í° ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
        }
        
        console.log(`âœ… Supabaseë¡œ ì´ë¯¸ì§€ í† í° ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${actualGeminiTokens.toLocaleString()}í† í°`);
      }

      // ğŸ“Š ì´ë¯¸ì§€ ìƒì„± í† í° ì‚¬ìš© ê¸°ë¡ (ì¶”ì ìš©) - Prisma ì—°ê²° ë¬¸ì œë¡œ ìƒëµ
      try {
        await prisma.transaction.create({
          data: {
            userId,
            type: TransactionType.TOKEN_USAGE,
            tokens: actualGeminiTokens,
            amount: 0,
            status: TransactionStatus.COMPLETED,
            description: options?.description || `ì´ë¯¸ì§€ ìƒì„±: ${actualGeminiTokens.toLocaleString()}í† í° (${options?.imageCount || 1}ì¥)`,
          },
        });
      } catch (transactionError) {
        console.warn('âš ï¸ Transaction ê¸°ë¡ ìƒì„± ì‹¤íŒ¨ (ì´ë¯¸ì§€ í† í° ì°¨ê°ì€ ì„±ê³µ):', transactionError);
      }

      console.log(`âœ… ì´ë¯¸ì§€ ìƒì„± í† í° ì‚¬ìš© ì™„ë£Œ: ${actualGeminiTokens.toLocaleString()}í† í°, ì”ì—¬: ${(remainingImageTokens - actualGeminiTokens).toLocaleString()}í† í°`);

      return {
          success: true,
          remainingTokens: remainingImageTokens - actualGeminiTokens,
        };
      } catch (tokenError) {
        console.error("âŒ í† í° ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", tokenError);
        return {
          success: false,
          error: "í† í° ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
        };
      }
    } catch (error) {
      secureError("Actual token usage error", error);
      return {
        success: false,
        error: "í† í° ì‚¬ìš© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
      };
    }
  }

  // í† í° ì‚¬ìš© (ì´ë¯¸ì§€ ìƒì„±) - ê¸°ì¡´ ë©”ì„œë“œ (í•˜ìœ„ í˜¸í™˜ìš©)
  // ì´ ë©”ì„œë“œëŠ” ë ˆê±°ì‹œ ì§€ì›ìš©ìœ¼ë¡œ, useActualTokensFromGeminië¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥
  async useTokensForImage(
    userId: string, 
    imageCount: number,
    options?: {
      highResolution?: boolean;
      saveCharacter?: boolean;
    }
  ): Promise<{
    success: boolean;
    remainingTokens?: number;
    dailyRemaining?: number;
    error?: string;
  }> {
    try {
      const supabase = await this.getSupabaseClient();
      
      // êµ¬ë… ì •ë³´ ì¡°íšŒ
      const { data: subscription } = await supabase
        .from('subscription')
        .select('*')
        .eq('userId', userId)
        .single();

      if (!subscription) {
        return { 
          success: false, 
          error: "êµ¬ë… ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" 
        };
      }

      // í•„ìš” í† í° ê³„ì‚° (ì†Œìˆ˜ì  ì²˜ë¦¬)
      let requiredTokens = imageCount * PLATFORM_PRICING.TOKENS_PER_IMAGE;
      if (options?.highResolution) {
        requiredTokens += imageCount * PLATFORM_PRICING.HIGH_RESOLUTION_TOKENS;
      }
      if (options?.saveCharacter) {
        requiredTokens += PLATFORM_PRICING.CHARACTER_SAVE_TOKENS;
      }
      requiredTokens = Math.ceil(requiredTokens); // ì˜¬ë¦¼ ì²˜ë¦¬

      const remainingTokens = subscription.tokensTotal - subscription.tokensUsed;
      
      if (remainingTokens < requiredTokens) {
        return {
          success: false,
          error: `í† í° ë¶€ì¡± (í•„ìš”: ${requiredTokens}, ë³´ìœ : ${remainingTokens})`,
          remainingTokens,
        };
      }

      // í† í° ì°¨ê°
      const { error: updateError } = await supabase
        .from('subscription')
        .update({ tokensUsed: subscription.tokensUsed + requiredTokens })
        .eq('userId', userId);

      if (updateError) {
        throw updateError;
      }

      return {
        success: true,
        remainingTokens: remainingTokens - requiredTokens,
      };
    } catch (error) {
      secureError("Token usage error", error);
      return {
        success: false,
        error: "í† í° ì‚¬ìš© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
      };
    }
  }

  // ì¼ì¼ ì œí•œ ì—†ìŒ - ì›”ê°„ í† í° í•œë„ë§Œ ì²´í¬

  // í† í° ì”ì•¡ ì¡°íšŒ (ìƒì„¸ ì •ë³´) - ìë™ ì´ˆê¸°í™” í¬í•¨ - N+1 ìµœì í™”ë¨
  async getBalance(userId: string): Promise<{
    // ğŸ”„ ë¶„ë¦¬ëœ í† í° ì •ë³´
    imageTokens: {
      balance: number;
      used: number;
      total: number;
      estimatedImagesRemaining: number;
    };
    textTokens: {
      balance: number;
      used: number;
      total: number;
      estimatedScriptsRemaining: number;
    };
    // ğŸš¨ ë ˆê±°ì‹œ í˜¸í™˜ì„± (deprecated)
    balance: number;
    used: number;
    total: number;
    estimatedImagesRemaining: number;
  }> {
    try {
      // í† í° ì´ˆê¸°í™” ì²´í¬ ë¨¼ì € ìˆ˜í–‰
      await checkAndResetTokensIfNeeded(userId);
      
      const supabase = await this.getSupabaseClient();
      
      // ğŸš€ êµ¬ë… ì •ë³´ ì¡°íšŒ (ë¶„ë¦¬ëœ í† í° í•„ë“œ í¬í•¨)
      const { data: subscription } = await supabase
        .from('subscription')
        .select('*')
        .eq('userId', userId)
        .single();

      if (!subscription) {
        // êµ¬ë…ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ FREE í”Œëœìœ¼ë¡œ ì²˜ë¦¬
        const freeConfig = PLAN_CONFIGS.FREE;
        
        return {
          imageTokens: {
            balance: freeConfig.imageTokens,
            used: 0,
            total: freeConfig.imageTokens,
            estimatedImagesRemaining: Math.floor(freeConfig.imageTokens / GEMINI_COST.TOKENS_PER_IMAGE),
          },
          textTokens: {
            balance: freeConfig.textTokens,
            used: 0,
            total: freeConfig.textTokens,
            estimatedScriptsRemaining: Math.floor(freeConfig.textTokens / 2000), // í‰ê·  2000í† í°/ëŒ€ë³¸
          },
          // ë ˆê±°ì‹œ í˜¸í™˜ì„±
          balance: freeConfig.platformTokens,
          used: 0,
          total: freeConfig.platformTokens,
          estimatedImagesRemaining: Math.floor(freeConfig.platformTokens / GEMINI_COST.TOKENS_PER_IMAGE),
        };
      }

      // ğŸ”„ ë¶„ë¦¬ëœ í† í° ê³„ì‚°
      const imageTokensTotal = subscription.imageTokensTotal || subscription.tokensTotal || 0;
      const imageTokensUsed = subscription.imageTokensUsed || subscription.tokensUsed || 0;
      const imageTokensBalance = imageTokensTotal - imageTokensUsed;

      const textTokensTotal = subscription.textTokensTotal || 0;
      const textTokensUsed = subscription.textTokensUsed || 0;
      const textTokensBalance = textTokensTotal - textTokensUsed;

      return {
        imageTokens: {
          balance: imageTokensBalance,
          used: imageTokensUsed,
          total: imageTokensTotal,
          estimatedImagesRemaining: Math.floor(imageTokensBalance / GEMINI_COST.TOKENS_PER_IMAGE),
        },
        textTokens: {
          balance: textTokensBalance,
          used: textTokensUsed,
          total: textTokensTotal,
          estimatedScriptsRemaining: Math.floor(textTokensBalance / 2000), // í‰ê·  2000í† í°/ëŒ€ë³¸
        },
        // ë ˆê±°ì‹œ í˜¸í™˜ì„± (ì´ë¯¸ì§€ í† í°ì„ ê¸°ë³¸ìœ¼ë¡œ)
        balance: imageTokensBalance,
        used: imageTokensUsed,
        total: imageTokensTotal,
        estimatedImagesRemaining: Math.floor(imageTokensBalance / GEMINI_COST.TOKENS_PER_IMAGE),
      };
    } catch (error) {
      secureError("Get balance error", error);
      return {
        imageTokens: {
          balance: 0,
          used: 0,
          total: 0,
          estimatedImagesRemaining: 0,
        },
        textTokens: {
          balance: 0,
          used: 0,
          total: 0,
          estimatedScriptsRemaining: 0,
        },
        // ë ˆê±°ì‹œ í˜¸í™˜ì„±
        balance: 0,
        used: 0,
        total: 0,
        estimatedImagesRemaining: 0,
      };
    }
  }

  // ì›”ê°„ í† í° ë¦¬ì…‹ (êµ¬ë… ê°±ì‹ ì‹œ)
  async resetMonthlyTokens(userId: string, plan: SubscriptionPlan): Promise<void> {
    try {
      const config = getPlanConfig(plan as PlanType);
      if (!config) {
        throw new Error("ì˜ëª»ëœ êµ¬ë… í”Œëœì…ë‹ˆë‹¤");
      }
      
      await prisma.subscription.update({
        where: { userId },
        data: {
          // ğŸ”„ ë¶„ë¦¬ëœ í† í° í•„ë“œ ë¦¬ì…‹
          imageTokensTotal: config.imageTokens,
          imageTokensUsed: 0,
          textTokensTotal: config.textTokens,
          textTokensUsed: 0,
          // ğŸš¨ ë ˆê±°ì‹œ í•„ë“œë„ ë™ì‹œ ì—…ë°ì´íŠ¸ (í•˜ìœ„ í˜¸í™˜ì„±)
          tokensTotal: config.platformTokens,
          tokensUsed: 0,
          currentPeriodStart: new Date(),
          currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        },
      });

      // í† í° ë¦¬ì…‹ ì™„ë£Œ
    } catch (error) {
      secureError("Reset monthly tokens error", error);
      throw error;
    }
  }

  // ìˆ˜ìµì„± ë¶„ì„
  async getMonthlyProfitAnalysis(userId: string): Promise<{
    revenue: number;
    actualCost: number;
    profit: number;
    margin: number;
    imageCount: number;
  }> {
    try {
      const subscription = await prisma.subscription.findUnique({
        where: { userId },
      });

      if (!subscription) {
        return {
          revenue: 0,
          actualCost: 0,
          profit: 0,
          margin: 0,
          imageCount: 0,
        };
      }

      const config = getPlanConfig(subscription.plan as PlanType);
      if (!config) {
        return {
          revenue: 0,
          actualCost: 0,
          profit: 0,
          margin: 0,
          imageCount: 0,
        };
      }

      // ì´ë²ˆ ë‹¬ ì‚¬ìš© ë‚´ì—­
      const startOfMonth = new Date();
      startOfMonth.setDate(1);
      startOfMonth.setHours(0, 0, 0, 0);

      const monthlyUsage = await prisma.transaction.findMany({
        where: {
          userId,
          type: TransactionType.TOKEN_PURCHASE,
          createdAt: { gte: startOfMonth },
          tokens: { lt: 0 },
        },
      });

      // ì‹¤ì œ ì´ë¯¸ì§€ ìƒì„± ìˆ˜ì™€ ì›ê°€ ê³„ì‚°
      let totalImages = 0;
      let totalCost = 0;

      monthlyUsage.forEach(usage => {
        // descriptionì—ì„œ ì´ë¯¸ì§€ ìˆ˜ ì¶”ì¶œ
        const match = usage.description?.match(/ì´ë¯¸ì§€ ìƒì„±: (\d+)ì¥/);
        if (match) {
          const imageCount = parseInt(match[1]);
          totalImages += imageCount;
          totalCost += imageCount * GEMINI_COST.COST_PER_IMAGE_KRW;
        }
      });

      const revenue = config.price;
      const profit = revenue - totalCost;
      const margin = revenue > 0 ? (profit / revenue) * 100 : 0;

      return {
        revenue,
        actualCost: totalCost,
        profit,
        margin: Math.round(margin),
        imageCount: totalImages,
      };
    } catch (error) {
      console.error("Profit analysis error:", error);
      return {
        revenue: 0,
        actualCost: 0,
        profit: 0,
        margin: 0,
        imageCount: 0,
      };
    }
  }

  // ì‚¬ìš© ë‚´ì—­ ì¡°íšŒ
  async getUsageHistory(
    userId: string,
    limit: number = 10
  ): Promise<Array<{
    date: Date;
    tokens: number;
    description: string;
    imageCount?: number;
    cost?: number;
  }>> {
    try {
      const transactions = await prisma.transaction.findMany({
        where: {
          userId,
          tokens: { not: null },
        },
        orderBy: { createdAt: "desc" },
        take: limit,
      });

      return transactions.map(t => {
        // descriptionì—ì„œ ì´ë¯¸ì§€ ìˆ˜ ì¶”ì¶œ
        const match = t.description?.match(/ì´ë¯¸ì§€ ìƒì„±: (\d+)ì¥/);
        const imageCount = match ? parseInt(match[1]) : undefined;
        
        return {
          date: t.createdAt,
          tokens: Math.abs(t.tokens || 0),
          description: t.description || "",
          imageCount,
          cost: imageCount ? imageCount * GEMINI_COST.COST_PER_IMAGE_KRW : undefined,
        };
      });
    } catch (error) {
      console.error("Get usage history error:", error);
      return [];
    }
  }

  // í† í° ë¶€ì¡± ì•Œë¦¼ í™•ì¸
  async checkLowBalance(userId: string): Promise<{
    isLow: boolean;
    balance: number;
    canGenerateImages: number;
  }> {
    const balanceInfo = await this.getBalance(userId);
    const canGenerate = Math.floor(balanceInfo.balance / GEMINI_COST.TOKENS_PER_IMAGE);
    
    return {
      isLow: canGenerate < 5, // 5ì¥ ë¯¸ë§Œ ìƒì„± ê°€ëŠ¥ì‹œ ì•Œë¦¼
      balance: balanceInfo.balance,
      canGenerateImages: canGenerate,
    };
  }

  // ì¶”ì²œì¸ ë³´ìƒ (ìˆ˜ìµì„± ê³ ë ¤)
  async grantReferralReward(
    referrerId: string,
    referredId: string
  ): Promise<void> {
    try {
      // ì´ë¯¸ ë³´ìƒì„ ë°›ì•˜ëŠ”ì§€ í™•ì¸
      const existingReward = await prisma.referralReward.findUnique({
        where: {
          referrerId_referredId: {
            referrerId,
            referredId,
          },
        },
      });

      if (existingReward) {
        return;
      }

      // ì¶”ì²œì¸: 20í† í° (20ì´ë¯¸ì§€, ì•½ 1040ì› ê°€ì¹˜)
      await this.addTokens(referrerId, 20);
      
      // ê°€ì…ì: 10í† í° (10ì´ë¯¸ì§€, ì•½ 520ì› ê°€ì¹˜)
      await this.addTokens(referredId, 10);

      // ë³´ìƒ ê¸°ë¡
      await prisma.referralReward.create({
        data: {
          referrerId,
          referredId,
          tokensRewarded: 20,
        },
      });
    } catch (error) {
      console.error("Grant referral reward error:", error);
      throw error;
    }
  }

  // í† í° ì¶”ê°€ (ê´€ë¦¬ììš© ë° ë‚´ë¶€ ì‚¬ìš©)
  async addTokens(userId: string, amount: number): Promise<void> {
    const subscription = await prisma.subscription.findUnique({
      where: { userId },
    });

    if (!subscription) {
      throw new Error("êµ¬ë… ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
    }

    await prisma.subscription.update({
      where: { userId },
      data: {
        tokensTotal: subscription.tokensTotal + amount,
      },
    });

    await prisma.transaction.create({
      data: {
        userId,
        type: TransactionType.TOKEN_PURCHASE,
        tokens: amount,
        amount: 0,
        status: TransactionStatus.COMPLETED,
        description: `í† í° ë³´ë„ˆìŠ¤: ${amount}ê°œ`,
      },
    });
  }

  /**
   * í…ìŠ¤íŠ¸ ìƒì„± í† í° ì‚¬ìš©ëŸ‰ ì¶”ì  (Gemini 2.5 Flash)
   * ë©¤ë²„ì‹­ë³„ ì›” í•œë„: FREE(10ë§Œ), PRO(300ë§Œ), PREMIUM(1000ë§Œ)
   */
  async useTextGenerationTokens(
    userId: string,
    actualGeminiTokens: number,
    options?: {
      requestType?: string;
      description?: string;
    }
  ): Promise<{
    success: boolean;
    remainingTextTokens?: number;
    userPlan?: string;
    monthlyLimit?: number;
    error?: string;
  }> {
    try {
      SecureLogger.metrics(`í…ìŠ¤íŠ¸ ìƒì„± í† í° ì‚¬ìš©`, { geminiTokens: actualGeminiTokens });

      const supabase = await this.getSupabaseClient();
      
      // ğŸš€ êµ¬ë… ì •ë³´ ì¡°íšŒ (MCP ì‚¬ìš© - Prisma ì—°ê²° ë¬¸ì œ ìš°íšŒ)
      let subscription;
      try {
        subscription = await prisma.subscription.findUnique({
          where: { userId },
          select: { 
            plan: true,
            textTokensTotal: true,
            textTokensUsed: true
          }
        });
      } catch (prismaError) {
        console.warn('âš ï¸ Prisma ì—°ê²° ì‹¤íŒ¨, Supabase ì§ì ‘ ì¿¼ë¦¬ë¡œ ëŒ€ì²´:', prismaError);
        
        // Supabase ì§ì ‘ ì¿¼ë¦¬ë¡œ ëŒ€ì²´
        const { data: supabaseSubscription, error: queryError } = await supabase
          .from('subscription')
          .select('plan, textTokensTotal, textTokensUsed')
          .eq('userId', userId)
          .single();
          
        if (queryError) {
          console.error('âŒ Supabase ì¿¼ë¦¬ë„ ì‹¤íŒ¨:', queryError);
          return {
            success: false,
            error: 'êµ¬ë… ì •ë³´ë¥¼ ì¡°íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
          };
        }
        
        return await this.processTextTokenUsageWithSupabase(userId, actualGeminiTokens, supabaseSubscription, options);
      }

      // êµ¬ë…ì´ ì—†ìœ¼ë©´ ì‚¬ìš©ìê°€ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìƒì„±
      if (!subscription) {
        console.log(`ğŸ‘¤ ìƒˆë¡œìš´ ì‚¬ìš©ì ìë™ ìƒì„±: ${userId.substring(0, 8)}...`);
        
        // Supabaseì—ì„œ ì‚¬ìš©ì í™•ì¸ë§Œ í•˜ê³ , ì—†ìœ¼ë©´ ìƒì„±
        const { data: userData } = await supabase
          .from('user')
          .select('id')
          .eq('id', userId)
          .single();

        if (!userData) {
          const { data: { user: authUser } } = await supabase.auth.admin.getUserById(userId);
          
          await supabase.from('user').insert({
            id: userId,
            email: authUser?.email || `user-${userId.substring(0, 8)}@example.com`,
            name: authUser?.user_metadata?.name || `ì‚¬ìš©ì-${userId.substring(0, 8)}`,
            createdAt: new Date().toISOString(),
          });
        }
      }

      const userPlan = subscription?.plan || 'FREE';
      const textTokensTotal = subscription?.textTokensTotal || 0;
      const textTokensUsed = subscription?.textTokensUsed || 0;
      const remainingTextTokens = textTokensTotal - textTokensUsed;

      console.log(`ğŸ‘¤ ì‚¬ìš©ì í”Œëœ: ${userPlan}, í…ìŠ¤íŠ¸ í† í°: ${textTokensUsed.toLocaleString()}/${textTokensTotal.toLocaleString()}í† í° ì‚¬ìš©`);

      // í…ìŠ¤íŠ¸ í† í° ì”ì•¡ í™•ì¸
      if (remainingTextTokens < actualGeminiTokens) {
        return {
          success: false,
          remainingTextTokens,
          userPlan,
          monthlyLimit: textTokensTotal,
          error: `í…ìŠ¤íŠ¸ ìƒì„± í† í° ë¶€ì¡± (${userPlan} í”Œëœ: ${textTokensTotal.toLocaleString()}í† í° ì´ëŸ‰, ì”ì—¬: ${remainingTextTokens.toLocaleString()}í† í°, ìš”ì²­: ${actualGeminiTokens.toLocaleString()}í† í°)`,
        };
      }

      // ğŸ”„ subscription í…Œì´ë¸”ì˜ textTokensUsed ì—…ë°ì´íŠ¸ (ì‹¤ì œ ì°¨ê°)
      await prisma.subscription.update({
        where: { userId },
        data: {
          textTokensUsed: {
            increment: actualGeminiTokens
          }
        }
      });

      // ğŸ“Š í…ìŠ¤íŠ¸ ìƒì„± í† í° ì‚¬ìš© ê¸°ë¡ (ì¶”ì ìš©)
      await prisma.transaction.create({
        data: {
          userId,
          type: TransactionType.TOKEN_USAGE,
          tokens: actualGeminiTokens,
          amount: 0,
          status: TransactionStatus.COMPLETED,
          description: options?.description || `í…ìŠ¤íŠ¸ ìƒì„±: ${actualGeminiTokens.toLocaleString()}í† í° (${userPlan} í”Œëœ)`,
        },
      });

      console.log(`âœ… í…ìŠ¤íŠ¸ ìƒì„± í† í° ì‚¬ìš© ì™„ë£Œ: ${actualGeminiTokens.toLocaleString()}í† í° (${userPlan} í”Œëœ, ì”ì—¬: ${(remainingTextTokens - actualGeminiTokens).toLocaleString()}í† í°)`);

      return {
        success: true,
        remainingTextTokens: remainingTextTokens - actualGeminiTokens,
        userPlan,
        monthlyLimit: textTokensTotal,
      };

    } catch (error) {
      secureError("í…ìŠ¤íŠ¸ ìƒì„± í† í° ì‚¬ìš© ì˜¤ë¥˜", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜",
      };
    }
  }

  /**
   * í…ìŠ¤íŠ¸ ìƒì„± í† í° ì”ì•¡ ì¡°íšŒ (ë©¤ë²„ì‹­ë³„)
   */
  async getTextGenerationBalance(userId: string): Promise<{
    remainingTokens: number;
    usedThisMonth: number;
    monthlyLimit: number;
    userPlan: string;
  }> {
    try {
      // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ê¸°ë³¸ê°’ ë°˜í™˜
      if (process.env.NODE_ENV === 'development') {
        return {
          remainingTokens: 1000000, // 100ë§Œ í† í°
          usedThisMonth: 0,
          monthlyLimit: 1000000,
          userPlan: 'PREMIUM'
        };
      }

      // ì‚¬ìš©ì êµ¬ë… ì •ë³´ ì¡°íšŒ
      const subscription = await prisma.subscription.findUnique({
        where: { userId },
        select: { plan: true }
      });

      const userPlan = subscription?.plan || 'FREE';
      const monthlyLimit = TEXT_GENERATION_CONFIG.PLAN_LIMITS[userPlan as keyof typeof TEXT_GENERATION_CONFIG.PLAN_LIMITS] || TEXT_GENERATION_CONFIG.PLAN_LIMITS.FREE;

      const currentMonth = new Date();
      const startOfMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth(), 1);
      const endOfMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth() + 1, 0);

      const monthlyUsage = await prisma.transaction.aggregate({
        where: {
          userId,
          createdAt: {
            gte: startOfMonth,
            lte: endOfMonth,
          },
          type: TransactionType.TOKEN_USAGE,
          description: {
            contains: 'í…ìŠ¤íŠ¸ ìƒì„±',
          },
        },
        _sum: {
          tokens: true,
        },
      });

      const usedThisMonth = monthlyUsage._sum.tokens || 0;
      const remainingTokens = monthlyLimit - usedThisMonth;

      return {
        remainingTokens: Math.max(0, remainingTokens),
        usedThisMonth,
        monthlyLimit,
        userPlan,
      };

    } catch (error) {
      secureError("í…ìŠ¤íŠ¸ í† í° ì”ì•¡ ì¡°íšŒ ì˜¤ë¥˜", error);
      return {
        remainingTokens: 0,
        usedThisMonth: 0,
        monthlyLimit: TEXT_GENERATION_CONFIG.PLAN_LIMITS.FREE,
        userPlan: 'FREE',
      };
    }
  }

  /**
   * Supabase ì§ì ‘ ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•œ í…ìŠ¤íŠ¸ í† í° ì²˜ë¦¬ (Prisma ì—°ê²° ì‹¤íŒ¨ ëŒ€ì²´)
   */
  private async processTextTokenUsageWithSupabase(
    userId: string,
    actualGeminiTokens: number,
    subscription: any,
    options?: { requestType?: string; description?: string }
  ): Promise<{
    success: boolean;
    remainingTextTokens?: number;
    userPlan?: string;
    monthlyLimit?: number;
    error?: string;
  }> {
    try {
      const supabase = await this.getSupabaseClient();

      if (!subscription) {
        return {
          success: false,
          error: 'êµ¬ë… ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤'
        };
      }

      const { plan, textTokensTotal, textTokensUsed } = subscription;
      const planConfig = PLAN_CONFIG[plan as keyof typeof PLAN_CONFIG] || PLAN_CONFIG.FREE;
      
      // ë‚¨ì€ í† í° ê³„ì‚°
      const remainingTokens = textTokensTotal - textTokensUsed;

      if (remainingTokens < actualGeminiTokens) {
        console.warn(`âŒ í…ìŠ¤íŠ¸ í† í° ë¶€ì¡±: ${remainingTokens}/${textTokensTotal} (í•„ìš”: ${actualGeminiTokens})`);
        return {
          success: false,
          error: `í…ìŠ¤íŠ¸ ìƒì„± í† í°ì´ ë¶€ì¡±í•©ë‹ˆë‹¤ (${plan} í”Œëœ: ${remainingTokens.toLocaleString()}/${textTokensTotal.toLocaleString()}í† í° ì”ì—¬)`,
          remainingTextTokens: remainingTokens,
          userPlan: plan,
          monthlyLimit: textTokensTotal
        };
      }

      // í† í° ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸
      const { error: updateError } = await supabase
        .from('subscription')
        .update({ 
          textTokensUsed: textTokensUsed + actualGeminiTokens 
        })
        .eq('userId', userId);

      if (updateError) {
        console.error('âŒ í† í° ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', updateError);
        return {
          success: false,
          error: 'í† í° ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤'
        };
      }

      console.log(`âœ… í…ìŠ¤íŠ¸ í† í° ì‚¬ìš© ì™„ë£Œ: ${actualGeminiTokens.toLocaleString()}í† í° (ì”ì—¬: ${(remainingTokens - actualGeminiTokens).toLocaleString()}/${textTokensTotal.toLocaleString()})`);

      return {
        success: true,
        remainingTextTokens: remainingTokens - actualGeminiTokens,
        userPlan: plan,
        monthlyLimit: textTokensTotal
      };

    } catch (error) {
      console.error('âŒ Supabase í…ìŠ¤íŠ¸ í† í° ì²˜ë¦¬ ì˜¤ë¥˜:', error);
      return {
        success: false,
        error: 'í…ìŠ¤íŠ¸ í† í° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'
      };
    }
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const tokenManager = new TokenManager();